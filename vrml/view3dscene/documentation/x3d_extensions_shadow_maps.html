<!DOCTYPE html>
<html lang="en">

<head>
<!-- meta suggested by bootstrap, but generally sensible -->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="Author" content="Michalis Kamburelis">



  <title>Shadow Maps | Castle Game Engine</title>


<!-- Bootstrap -->
<link href="https://castle-engine.sourceforge.io/kambi-php-lib/bootstrap/css/bootstrap.min.css" rel="stylesheet">
<!-- Bootstrap theme -->
<link href="https://castle-engine.sourceforge.io/kambi-php-lib/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">

<!-- Colorbox -->
<link href="https://castle-engine.sourceforge.io/kambi-php-lib/colorbox/example3/colorbox.css" type="text/css" rel="stylesheet">

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
<!--[if lt IE 9]>
  <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
  <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


<link rel="alternate" type="application/rss+xml"
  title="Castle Game Engine - News Feed"
  href="https://castle-engine.sourceforge.io/news_feed.php">

<link type="text/css" rel="stylesheet" media="all" href="https://castle-engine.sourceforge.io/castle-engine.css">


<script type="text/javascript" src="https://castle-engine.sourceforge.io/castle-engine.js"></script>

<style type="text/css">
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for delphi
 * CSS class: , CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2014 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.delphi .de1, .delphi .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.delphi  {font-family:monospace;}
.delphi .imp {font-weight: bold; color: red;}
.delphi li, .delphi .li1 {font-weight: normal; vertical-align:top;}
.delphi .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.delphi .li2 {font-weight: bold; vertical-align:top;}
.delphi .kw1 {color: #000000; font-weight: bold;}
.delphi .kw2 {color: #000000; font-weight: bold;}
.delphi .kw3 {color: #000066;}
.delphi .kw4 {color: #000066; font-weight: bold;}
.delphi .co1 {color: #808080; font-style: italic;}
.delphi .co2 {color: #008000; font-style: italic;}
.delphi .coMULTI {color: #808080; font-style: italic;}
.delphi .es0 {color: #ff0000; font-weight: bold;}
.delphi .br0 {color: #000066;}
.delphi .sy0 {color: #000066;}
.delphi .sy1 {color: #000066;}
.delphi .sy2 {color: #000066;}
.delphi .sy3 {color: #000066;}
.delphi .st0 {color: #ff0000;}
.delphi .nu0 {color: #0000ff;}
.delphi .me1 {color: #006600;}
.delphi .re0 {color: #0000cc;}
.delphi .re1 {color: #ff0000;}
.delphi .ln-xtra, .delphi li.ln-xtra, .delphi div.ln-xtra {background-color: #ffc;}
.delphi span.xtra { display:block; }
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for vrmlx3d
 * CSS class: , CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2014 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.vrmlx3d .de1, .vrmlx3d .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.vrmlx3d  {font-family:monospace;}
.vrmlx3d .imp {font-weight: bold; color: red;}
.vrmlx3d li, .vrmlx3d .li1 {font-weight: normal; vertical-align:top;}
.vrmlx3d .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.vrmlx3d .li2 {font-weight: bold; vertical-align:top;}
.vrmlx3d .kw1 {color: #000000; font-weight: bold;}
.vrmlx3d .kw2 {color: #c20cb9; font-weight: bold;}
.vrmlx3d .kw3 {color: #7a0874; font-weight: bold;}
.vrmlx3d .co0 {color: #666666; font-style: italic;}
.vrmlx3d .co1 {color: #800000;}
.vrmlx3d .co2 {color: #cc0000; font-style: italic;}
.vrmlx3d .co3 {color: #000000; font-weight: bold;}
.vrmlx3d .co4 {color: #666666;}
.vrmlx3d .es1 {color: #000099; font-weight: bold;}
.vrmlx3d .es2 {color: #007800;}
.vrmlx3d .es3 {color: #007800;}
.vrmlx3d .es4 {color: #007800;}
.vrmlx3d .es5 {color: #780078;}
.vrmlx3d .es_h {color: #000099; font-weight: bold;}
.vrmlx3d .br0 {color: #7a0874; font-weight: bold;}
.vrmlx3d .sy0 {color: #000000; font-weight: bold;}
.vrmlx3d .st0 {color: #ff0000;}
.vrmlx3d .st_h {color: #ff0000;}
.vrmlx3d .nu0 {color: #000000;}
.vrmlx3d .re0 {color: #007800;}
.vrmlx3d .re1 {color: #007800;}
.vrmlx3d .re2 {color: #007800;}
.vrmlx3d .re4 {color: #007800;}
.vrmlx3d .re5 {color: #660033;}
.vrmlx3d .ln-xtra, .vrmlx3d li.ln-xtra, .vrmlx3d div.ln-xtra {background-color: #ffc;}
.vrmlx3d span.xtra { display:block; }
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: , CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2014 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c .de1, .c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.c  {font-family:monospace;}
.c .imp {font-weight: bold; color: red;}
.c li, .c .li1 {font-weight: normal; vertical-align:top;}
.c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c .li2 {font-weight: bold; vertical-align:top;}
.c .kw1 {color: #b1b100;}
.c .kw2 {color: #000000; font-weight: bold;}
.c .kw3 {color: #000066;}
.c .kw4 {color: #993333;}
.c .co1 {color: #666666; font-style: italic;}
.c .co2 {color: #339933;}
.c .coMULTI {color: #808080; font-style: italic;}
.c .es0 {color: #000099; font-weight: bold;}
.c .es1 {color: #000099; font-weight: bold;}
.c .es2 {color: #660099; font-weight: bold;}
.c .es3 {color: #660099; font-weight: bold;}
.c .es4 {color: #660099; font-weight: bold;}
.c .es5 {color: #006699; font-weight: bold;}
.c .br0 {color: #009900;}
.c .sy0 {color: #339933;}
.c .st0 {color: #ff0000;}
.c .nu0 {color: #0000dd;}
.c .nu6 {color: #208080;}
.c .nu8 {color: #208080;}
.c .nu12 {color: #208080;}
.c .nu16 {color:#800080;}
.c .nu17 {color:#800080;}
.c .nu18 {color:#800080;}
.c .nu19 {color:#800080;}
.c .me1 {color: #202020;}
.c .me2 {color: #202020;}
.c .ln-xtra, .c li.ln-xtra, .c div.ln-xtra {background-color: #ffc;}
.c span.xtra { display:block; }
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for xml
 * CSS class: , CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2014 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.xml .de1, .xml .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.xml  {font-family:monospace;}
.xml .imp {font-weight: bold; color: red;}
.xml li, .xml .li1 {font-weight: normal; vertical-align:top;}
.xml .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.xml .li2 {font-weight: bold; vertical-align:top;}
.xml .es0 {color: #000099; font-weight: bold;}
.xml .br0 {color: #66cc66;}
.xml .sy0 {color: #66cc66;}
.xml .st0 {color: #ff0000;}
.xml .nu0 {color: #cc66cc;}
.xml .sc-1 {color: #808080; font-style: italic;}
.xml .sc0 {color: #00bbdd;}
.xml .sc1 {color: #ddbb00;}
.xml .sc2 {color: #339933;}
.xml .sc3 {color: #009900;}
.xml .re0 {color: #000066;}
.xml .re1 {color: #000000; font-weight: bold;}
.xml .re2 {color: #000000; font-weight: bold;}
.xml .ln-xtra, .xml li.ln-xtra, .xml div.ln-xtra {background-color: #ffc;}
.xml span.xtra { display:block; }
</style>

<script type="text/javascript">
var _bftn_options = {
//always_show_widget: true // @type {Boolean}
};
</script>
<!-- script src="https://widget.battleforthenet.com/widget.js" async></script -->

<script src="https://apis.google.com/js/platform.js" async defer></script></head>

<body >


  <nav class="navbar navbar-default">
    <div class="container-fluid">
      <!-- Uncomment this for toggable navbar -->
      <!--
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      -->

      <ul class="nav nav-tabs navbar-right">
        <li><a href="https://patreon.com/castleengine" class="navbar-link">Support the engine on<br><img class="patreon-logo" src="https://castle-engine.sourceforge.io/images/patreonlogoorange_45px.png" alt="Patreon" /></a></li>
      </ul>

      <!--button type="button" class="btn btn-default navbar-btn navbar-right" style="margin-right: 0px;"><a href="https://patreon.com/castleengine" class="navbar-link">Support us on<br><img style="height: 40px" src="https://castle-engine.sourceforge.io/images/patreonlogoorange.png" alt="Patreon" /></a></button-->

      <!--p class="navbar-text navbar-right"><a href="https://patreon.com/castleengine" class="navbar-link">Support us on<br><img style="height:50px" src="https://castle-engine.sourceforge.io/images/patreonlogoorange.png" alt="Patreon" /></a></p-->

      <div class="navbar-header">
        <a class="navbar-brand" href="https://castle-engine.sourceforge.io/index.php">
          <img alt="" src="https://castle-engine.sourceforge.io/images/header_icon.png">
        </a>
        <a class="navbar-brand" href="https://castle-engine.sourceforge.io/index.php">
          Castle Game Engine
        </a>
      </div>
      
      
    <!-- Uncomment this for toggable navbar -->
    <!--div class="collapse navbar-collapse" id="main-navbar-collapse-1" -->
    <ul class="nav nav-tabs"><li class=""><a href="https://castle-engine.sourceforge.io/index.php">Download</a></li><li class=""><a href="https://castle-engine.sourceforge.io/wp/">News</a></li><li class=""><a href="https://castle-engine.sourceforge.io/features.php">Features</a></li><li class=" dropdown"><a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Documentation <span class="caret"></span></a><ul class="dropdown-menu"><li><a href="https://castle-engine.sourceforge.io/documentation.php">Getting Started</a></li><li><a href="https://castle-engine.sourceforge.io/manual_intro.php">Manual</a></li><li><a href="https://castle-engine.sourceforge.io/creating_data_intro.php">Creating Game Data</a></li><li><a href="https://castle-engine.sourceforge.io/apidoc/html/index.html">API Reference</a></li><li><a href="http://castle-engine.io/modern_pascal_introduction.html">Modern Object Pascal Introduction</a></li><li><a href="https://castle-engine.sourceforge.io/documentation_more.php">More...</a></li></ul></li><li class=" active"><a href="vrml_x3d.html">Scene Graph (X3D)</a></li><li class=""><a href="view3dscene.html" title="VRML / X3D browser, and a viewer for other 3D model formats">view3dscene</a></li><li class=""><a href="https://castle-engine.sourceforge.io/talk.php" title="Ask for help, report bugs, discuss features">Talk with us</a></li><li class=""><a href="https://castle-engine.sourceforge.io/all_programs.php" title="All the games and tools using our 3D engine">Games and Tools</a></li>
    </ul>
    <!-- Uncomment this for toggable navbar -->
    <!--/div-->
    </div>

    
  </nav><div class="container-fluid">
      <div class="row">
        <div class="col-sm-9 col-sm-push-3 content-near-sidebar">
          <div class="header_breadcrumbs"><a href="https://castle-engine.sourceforge.io/index.php">Home</a> &#187; <a href="vrml_x3d.html">Scene Graph (X3D)</a> &#187; <a href="https://castle-engine.sourceforge.io/x3d_larger_extensions.php">Larger X3D Extensions</a></div>
<h1>Shadow Maps</h1>
<p>Contents:
<div class="table_of_contents"><ol>
<li><a href="#section_intro">Intro</a>
</li>
<li><a href="#section_examples">Examples</a>
</li>
<li><a href="#section_light_shadows_on_everything">Define lights casting shadows on everything</a>
</li>
<li><a href="#section_receive_shadows">Define shadow receivers</a>
</li>
<li><a href="#section_lower_level">The lower-level extensions</a>
<ol>
<li><a href="#section_lower_level_overview">Overview of the lower-level extensions</a>
</li>
<li><a href="#section_light_parameters">Light sources parameters</a>
</li>
<li><a href="#section_generated_shadow_map">Automatically generated shadow maps</a>
</li>
<li><a href="#section_texture_projective">Projective texture mapping</a>
</li>
<li><a href="#section_receive_shadows_to_lower_level">How the receiveShadows field maps to the lower-level extensions</a>
</li>
</ol>
</li>
<li><a href="#section_shadow_caster">Optionally specify shadow casters (<code>Appearance.shadowCaster</code>)</a>
</li>
</ol>
</div>
<h2 id="section_intro">1. Intro</h2>

  <div style="border: outset thin black;
    background: #f8d785;
    padding: 0.3em;
    width: 80%;
    margin: 1em auto;"><p style="margin-top: 0px;">For reasoning behind these extensions,
  see also my paper <a href="https://castle-engine.sourceforge.io/shadow_maps_x3d.pdf">Shadow maps and projective texturing in X3D</a>
  (accepted for Web3D 2010 conference). PDF linked here has some absolutely minor
  corrections (for <code style="background-color: transparent;">projection*</code> fields and fixed URLs)
  compared to the conference version.
  <a href="https://castle-engine.sourceforge.io/shadow_maps_x3d_slides.pdf">The slides
  from the presentation</a> are also available.</p>

  <p>Specification below comes from
  this paper (section 4). Text below has some additional notes,
  mostly specific to our engine and implementation.</p>

  <p style="margin-bottom: 0px;">Note that the paper, and so portions of the text below,
  are <a href="http://www.acm.org/publications/policies/copyright_policy">Copyright 2010 by ACM, Inc.</a>
  See the link for details, in general non-commercial use is fine,
  but commercial use usually requires asking ACM for permission.
  This is a necessary exception from my usual rules of publishing everything on GNU GPL.</p>
  </div>

  <table class="thumbnails thumbnails-align-right"><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/trees_river_shadow_maps.png"
             class="screenshot"
             title="Scenery with shadow maps"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/trees_river_shadow_maps.png"
            alt="Scenery with shadow maps"
          /></a></td></tr><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/sunny_street_above_view.png"
             class="screenshot"
             title="Just a screenshot with nice shadow maps"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/sunny_street_above_view.png"
            alt="Just a screenshot with nice shadow maps"
          /></a></td></tr><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/sunny_street_tree_hard.png"
             class="screenshot"
             title="Close up shadows on the tree. Notice that leaves (modeled by alpha-test texture) also cast correct shadows."><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/sunny_street_tree_hard.png"
            alt="Close up shadows on the tree. Notice that leaves (modeled by alpha-test texture) also cast correct shadows."
          /></a></td></tr><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/sunny_street_tree_pcf16.png"
             class="screenshot"
             title="Close up shadows on the tree, with Percentage Closer Filtering."><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/sunny_street_tree_pcf16.png"
            alt="Close up shadows on the tree, with Percentage Closer Filtering."
          /></a></td></tr></table>
  <p>One of the shadows algorithms implemented in our engine is
  <i>shadow maps</i>.

  <p><i>Shadow maps</i> work completely orthogonal to <i>shadow
  volumes</i> (see
  <a href="x3d_extensions.html#section_ext_shadows">shadow volumes docs</a>), which means that you can freely mix
  both shadow approaches within a single scene.
  <i>Shadow maps</i>, described here, are usually more adviced: they are simpler to use
  (in the simplest case, just add "<code>shadows TRUE</code>" to your light source,
  and it just works with an abritrary 3D scene),
  and have a better implementation (shadow maps from multiple light sources
  cooperate perfectly thanks to the shaders pipeline).</p>

  <p><i>Most important TODO about shadow maps:</i> <code>PointLight</code>
  sources do not cast shadow maps yet. (Easy to do, please report if you need it.)

<h2 id="section_examples">2. Examples</h2>

  <p><a href="demo_models.html">Our VRML/X3D demo models</a> contain many demos using shadow maps.
  Download them and open with <a href="view3dscene.html">view3dscene</a> files insde <code>shadow_maps</code> subdirectory.
  See in particular the nice model inside <code>shadow_maps/sunny_street/</code>,
  that was used for some screenshots visible on this page.</p>

<h2 id="section_light_shadows_on_everything">3. Define lights casting shadows on everything</h2>

  <p>In the very simplest case, to make the light source just cast shadows
  on everything, set the <code>shadows</code> field of the light source
  to <code>TRUE</code>.

  <pre class="vrml_extension_spec"><b>*Light {</b>
  ... all normal *Light fields ...
  SFBool     []            <b>shadows     FALSE     </b>
<b>}</b>
</pre>
  <p>This is equivalent to adding this light source to every shape's
  <code>receiveShadows</code> field. Read on to know more details.</p>

  <p>This is the simplest extension to enable shadows.

  <p>TODO: In the future, this field (<code>shadows</code> on light) and
  <code>receiveShadows</code> field (see below) should be suitable for
  other shadows implementations too
  We plan to use it for shadow volumes in the future too
  (removing old <code>shadowVolumesMain</code> extensions and such),
  and maybe ray-tracer too. <code>shadowCaster</code> (see below) already works
  for all our shadows implementations.</p>

  <p>If you use <a href="x3d_implementation_shaders.html">X3D shader nodes, like <code>ComposedShader</code> and related nodes</a>, be aware that your custom shaders
  may be ignored. Browsers have to use internal shaders to produce nice
  shading for shadow receivers. Use instead
  <a href="compositing_shaders.html">our compositing shaders extensions for X3D, like <code>Effect</code> and related nodes</a> to write shader code that can cooperate
  with other effects (like shadow maps, and much more).
  Or (less adviced)
  use the lower-level nodes described below to activate shadow maps more manuallly.</p>

<h2 id="section_receive_shadows">4. Define shadow receivers</h2>

  To enable the shadows on specific receivers, use this field:

  <pre class="vrml_extension_spec"><b>Appearance {</b>
  ... all normal Appearance fields ...
  MFNode     []            <b>receiveShadows  []        </b>  #&nbsp;[X3DLightNode] list
<b>}</b>
</pre>
  <p>Each light present in the <code>receiveShadows</code> list will cast shadows on
  the given shape. That is, contribution of the light source
  will be scaled down if the light is occluded at a given fragment.
  The whole light contribution is affected, including the ambient term.
  We do not make any additional changes to the X3D lighting model.
  The resulting fragment color is the sum of all the visible lights (visible
  because they are not occluded, or because they don't cast shadows on this shape),
  modified by the material emissive color and fog, following the X3D specification.</p>

<h2 id="section_lower_level">5. The lower-level extensions</h2>

<h3 id="section_lower_level_overview">5.1. Overview of the lower-level extensions</h3>

  <p>The following extensions make it possible to precisely setup and control
  shadow maps. Their use requires a basic knowledge of the shadow map approach,
  and they are necessarily closely tied to the shadow map workflow.
  On the other hand, they allow the author to define custom shaders
  for the scene and control every important detail of the shadow mapping process.</p>

  <p>These lower-level extensions give a complete and flexible system to
  control the shadow maps, making the <code>Appearance.receiveShadows</code>
  and <code>X3DLightNode.shadows</code> features only a shortcuts
  for the usual setup.</p>

  <p>We make a shadow map texture by the <code>GeneratedShadowMap</code> node,
  and project it on the shadow receiver by
  <code>ProjectedTextureCoordinate</code>.
  An example X3D code (in classic encoding) for a shadow map setup:</p>

<pre class="vrml_code">
  DEF MySpot SpotLight {
    location 0 0 10
    direction 0 0 -1
    <b>projectionNear 1
    projectionFar 20</b>
  }

  Shape {
    appearance Appearance {
      material Material { }
      texture <b>GeneratedShadowMap { light USE MySpot update "ALWAYS" }</b>
    }
    geometry IndexedFaceSet {
      texCoord <b>ProjectedTextureCoordinate {
        projector USE MySpot
      }</b>
      # ... other IndexedFaceSet fields
    }
  }
</pre>

  <p>Note that the shadow texture will be applied in a very trivial way,
  just to generate intensity values (0 - in shadow, 1 - not in shadow).
  If you want to have some nice shading, you should use GLSL shader
  to sample the depth texture (like <code>shadow2DProj(shadowMap, gl_TexCoord[0]).r</code>)
  and do there any shading you want. Using shaders is generally
  the way to make shadow mapping both beautiful and in one pass (read: fast),
  and it's the way of the future anyway. You can start from a trivial
  fragment shader in our examples:
  <a href="http://svn.code.sf.net/p/castle-engine/code/trunk/demo_models/shadow_maps/shadow_map.fs">shadow_map.fs</a>.

  <p>Note that view3dscene's menu items <i>View -&gt; Shadow Maps -&gt; ...</i>
  do not affect the lower-level shadow maps. Essentially, when using
  the lower-level nodes, you directly control the shaders (and everything
  else) yourself.

  <p>Remember: If you don't want to write your own GLSL shader,
  and you need nice shadows, then these lower-level extensions are not for you.
  Instead, you could use easy <code>receiveShadows</code>:</p>

<pre class="vrml_code">
  DEF MySpot SpotLight {
    location 0 0 10
    direction 0 0 -1
  }

  Shape {
    appearance Appearance {
      material Material { }
      <b>receiveShadows MySpot</b>
    }
    geometry IndexedFaceSet {  ....  }
  }
</pre>

  <p>Using the <code>receiveShadows</code> approach is simpler,
  also the browser will use nice internal GLSL shaders automatically.</p>

<h3 id="section_light_parameters">5.2. Light sources parameters</h3>

  <p>The motivation behind the extensions in this section is that we want to use
  light sources as cameras. This means that lights need additional parameters
  to specify projection details.

  <p>To every X3D light node (<code>DirectionalLight</code>, <code>SpotLight</code>,
  <code>PointLight</code>) we add new fields:

  <pre class="vrml_extension_spec"><b>*Light {</b>
  ... all normal *Light fields ...
  SFFloat    [in,out]      <b>projectionNear        0         </b>  #&nbsp;must be &gt;= 0
  SFFloat    [in,out]      <b>projectionFar         0         </b>  #&nbsp;must be &gt; projectionNear, or = 0
  SFVec3f    [in,out]      <b>up                    0 0 0     </b>
  SFNode     []            <b>defaultShadowMap      NULL      </b>  #&nbsp;[GeneratedShadowMap]
<b>}</b>
</pre>
  <p>The fields <code>projectionNear</code> and <code>projectionFar</code> specify the near
  and far values for the projection used when rendering to the shadow map texture.
  These are distances from the light position, along the light direction.
  You should always try to make <code>projectionNear</code> as large as possible
  and <code>projectionFar</code> as small as possible,
  this will make depth precision better (keeping <code>projectionNear</code> large
  is more important for this). At the same time, your projection range
  must include all your shadow casters.

  <p>The field <code>up</code> is the "up" vector of the light camera when capturing
  the shadow map. This is used only with non-point lights
  (<code>DirectionalLight</code> and <code>SpotLight</code>).
  Although we know the direction of the light source,
  but for shadow mapping we also need to know the "up" vector to have camera
  parameters fully determined.

  <p>You usually don't need to provide the "<code>up</code>" vector value in the file.
  We intelligently guess (or fix your provided value) to be always Ok.
  The "up" value is processed like this:
  <ol>
    <li>If <i>up = zero</i> (default), assume <i>up := +Y axis (0,1,0)</i>.</li>
    <li>If <i>up is parallel to the direction vector</i>,
      set <i>up := arbitrary vector orthogonal to the direction</i>.</li>
    <li>Finally, make sure up vector is exactly orthogonal to the direction
      (eventually rotating it slightly).</li>
  </ol>

  <p>These properties are specified at the light node, because both
  shadow map generation and texture coordinate calculation must know them,
  and use the same values (otherwise results would not be of much use).

  <p>The field <code>defaultShadowMap</code> is meaningful only when some
  shape uses the <code>receiveShadows</code> feature. This will be described
  in the <a href="#section_ext_receive_shadows_vs_lower_level">later section</a>.

  <p><code>DirectionalLight</code> gets additional fields to specify orthogonal
  projection rectangle (projection XY sizes) and location for
  the light camera. Although directional light is conceptually at infinity
  and doesn't have a location, but for making a texture projection
  we actually need to define the light's location.

  <pre class="vrml_extension_spec"><b>DirectionalLight {</b>
  ... all normal *Light fields ...
  SFVec4f    [in,out]      <b>projectionRectangle   0 0 0 0   </b>  #&nbsp;
      # left, bottom, right, top (order like for OrthoViewpoint.fieldOfView).
      # Must be left &lt; right and bottom &lt; top, or all zero
  SFVec3f    [in,out]      <b>projectionLocation    0 0 0     </b>  #&nbsp;affected by node's transformation
<b>}</b>
</pre>
  <p>When <code>projectionNear</code>, <code>projectionFar</code>, <code>up</code>,
  <code>projectionRectangle</code> have (default) zero values, then some sensible
  values are automatically calculated for them by the browser.
  <code>projectionLocation</code> will also be automaticaly adjusted,
  if and only if <code>projectionRectangle</code> is zero.
  This will work perfectly for shadow receivers marked by the
  <code>receiveShadows</code> field.
  <b>This feature was not "invented" at the time of submitting the
  <a href="https://castle-engine.sourceforge.io/shadow_maps_x3d.pdf">PDF paper to the <i>Web3D 2010 conference</i></a>,
  so it's not documented there.</b>

  <table class="thumbnails thumbnails-align-right"><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/tex_projected_spot_0.png"
             class="screenshot"
             title="SpotLight projecting texture"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/tex_projected_spot_0.png"
            alt="SpotLight projecting texture"
          /></a></td></tr><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/tex_projected_spot_1.png"
             class="screenshot"
             title="SpotLight projecting texture 2"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/tex_projected_spot_1.png"
            alt="SpotLight projecting texture 2"
          /></a></td></tr></table>
  <p>SpotLight gets additional field to explicitly specify a perspective
  projection angle.

  <pre class="vrml_extension_spec"><b>SpotLight {</b>
  ... all normal *Light fields ...
  SFFloat    [in,out]      <b>projectionAngle       0         </b>
<b>}</b>
</pre>
  <p>Leaving <code>projectionAngle</code> at the default zero value is equivalent
  to setting <code>projectionAngle</code> to <code>2 * cutOffAngle</code>.
  This is usually exactly what is needed.
  Note that the <code>projectionAngle</code> is
  the vertical and horizontal field of view for the square texture,
  while <code>cutOffAngle</code> is the angle of the half of the cone
  (that's the reasoning for *2 multiplier).
  Using <code>2 * cutOffAngle</code> as <code>projectionAngle</code>
  makes the perceived light cone fit nicely inside the projected
  texture rectangle. It also means that some texture space is essentially
  wasted &mdash; we cannot perfectly fit a rectangular texture into a circle shape.

  <p>Images on the right show how a light cone fits within
  the projected texture.

<h3 id="section_generated_shadow_map">5.3. Automatically generated shadow maps</h3>

  <p>Now that we can treat lights as cameras, we want to render shadow maps
  from the light sources. The rendered image is stored as a texture,
  represented by a new node:

  <pre class="vrml_extension_spec"><b>GeneratedShadowMap : X3DTextureNode {</b>
  SFNode     [in,out]      <b>metadata         NULL                </b>  #&nbsp;[X3DMetadataObject]
  SFString   [in,out]      <b>update           "NONE"              </b>  #&nbsp;["NONE"|"NEXT_FRAME_ONLY"|"ALWAYS"]
  SFInt32    []            <b>size             128                 </b>
  SFNode     []            <b>light            NULL                </b>  #&nbsp;any light node
  SFFloat    [in,out]      <b>scale            4.0                 </b>
  SFFloat    [in,out]      <b>bias             4.0                 </b>
  SFString   []            <b>compareMode      "COMPARE_R_LEQUAL"  </b>  #&nbsp;["COMPARE_R_LEQUAL" | "COMPARE_R_GEQUAL" | "NONE"]
<b>}</b>
</pre>
  <table class="thumbnails thumbnails-align-right"><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/depths_light_mapped.png"
             class="screenshot"
             title="Shadow map, as seen from the light"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/depths_light_mapped.png"
            alt="Shadow map, as seen from the light"
          /></a></td></tr><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/depths_camera_mapped.png"
             class="screenshot"
             title="Shadow map mapped over the scene"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/depths_camera_mapped.png"
            alt="Shadow map mapped over the scene"
          /></a></td></tr></table>
  <p>The <code>update</code> field determines how often the shadow map should be
  regenerated. It is analogous to the <code>update</code> field in the standard
  <code>GeneratedCubeMapTexture</code> node.

  <ul>
    <li><p><b><code>"NONE"</code></b> means that the texture is not generated.
      It is the default value (because it's the most conservative,
      so it's the safest value).</p></li>

    <li><p><b><code>"ALWAYS"</code></b> means that the shadow map must be always accurate.
      Generally, it needs to be generated every time shadow caster's geometry
      noticeably changes.
      The simplest implementation may just render the shadow map at every frame.</p></li>

    <li><p><b><code>"NEXT_FRAME_ONLY"</code></b> says to update the shadow map
      at the next frame, and afterwards change the value back to <code>"NONE"</code>.
      This gives the author an explicit control over when the texture is
      regenerated, for example by sending <code>"NEXT_FRAME_ONLY"</code>
      values by a <code>Script</code> node.</p></li>
  </ul>

  <p>The field <code>size</code> gives the size of the (square) shadow map texture
  in pixels.

  <p>The field <code>light</code> specifies the light node from which to generate the map.
  Ideally, implementation should support all three X3D light source types.
  <code>NULL</code> will prevent the texture from generating.
  It's usually comfortable to <code>"USE"</code> here some existing light node,
  instead of defining a new one.
  TODO: for now, we do not handle shadow maps from <code>PointLight</code>
  nodes.

  <p>Note that the light node instanced inside the <code>GeneratedShadowMap.light</code>
  or <code>ProjectedTextureCoordinate.projector</code> fields isn't
  considered a normal light, that is it doesn't shine anywhere.
  It should be defined elsewhere in the scene to actually
  act like a normal light. Moreover, it should not be
  instanced many times (outside of <code>GeneratedShadowMap.light</code>
  and <code>ProjectedTextureCoordinate.projector</code>), as then it's
  unspecified from which view we will generate the shadow map.

  <table class="thumbnails thumbnails-align-right"><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/scale_bias_right.png"
             class="screenshot"
             title="Correct bias/scale"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/scale_bias_right.png"
            alt="Correct bias/scale"
          /></a></td></tr><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/scale_bias_too_large.png"
             class="screenshot"
             title="Too large bias/scale"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/scale_bias_too_large.png"
            alt="Too large bias/scale"
          /></a></td></tr><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/scale_bias_too_small.png"
             class="screenshot"
             title="Too small bias/scale"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/scale_bias_too_small.png"
            alt="Too small bias/scale"
          /></a></td></tr><tr><td>
          <a href="https://castle-engine.sourceforge.io/images/original_size/lights_editor_new_shadows.png"
             class="screenshot"
             title="Lights editor with bias and scale"><img
            style="float: right"
            src="https://castle-engine.sourceforge.io/images/thumb_size/lights_editor_new_shadows.png"
            alt="Lights editor with bias and scale"
          /></a></td></tr></table>
  <p>Fields <code>scale</code> and <code>bias</code> are used
  to offset the scene rendered to the shadow map.
  This avoids the precision problems inherent in the shadow maps comparison.
  In short, increase them if you see
  a strange noise appearing on the shadow casters (but don't increase them too much,
  or the shadows will move back).
  You may increase the <code>bias</code> a little more
  carelessly (it is multiplied by a constant implementation-dependent offset,
  that is usually something very small).
  Increasing the <code>scale</code> has to be done a little more carefully
  (it's effect depends on the polygon slope).

  <p>Images on the right show the effects of various
  <code>scale</code> and <code>bias</code> values.

  <p><b>You can adjust the <code>bias</code>, <code>scale</code>
  and <code>size</code> interactively in
  <a href="view3dscene.html">view3dscene</a>.</b>
  Using the <i>Edit->Lights Editor</i> feature, you can configure
  the <code>defaultShadowMap</code> parameters for a given light,
  and immediately see the results.

  <p>For an OpenGL implementation<!-- of "classic" shadow maps,-->
  that offsets the geometry rendered into the shadow map,
  <code>scale</code> and <code>bias</code> are an obvious parameters (in this order)
  for the <code>glPolygonOffset</code> call.
  Other implementations are free to ignore these parameters, or derive
  from them values for their offset methods.
  <!-- Not true now:
  Our <i>Variance Shadow Maps</i> implementation simply ignores these offsets.
  -->

  <p>Field <code>compareMode</code> allows to additionally do depth comparison
  on the texture. For texture coordinate <i>(s, t, r, q)</i>,
  compare mode allows to compare <i>r/q</i> with <i>texture(s/q, t/q)</i>.
  Typically combined with the projective texture mapping, this is the moment when we
  actually decide which screen pixel is in the shadow and which is not.
  Default value <code>COMPARE_R_LEQUAL</code> is the most useful
  value for standard shadow mapping, it generates 1 (true) when
  <i>r/q <= texture(s/q, t/q)</i>, and 0 (false) otherwise. Recall from
  the shadow maps algorithm that, theoretically, assuming infinite shadow map
  resolution and such, <i>r/q</i> should never be smaller than the texture value
  (it can only be equal or larger).

  <p>When the <code>compareMode</code> is set to <code>NONE</code>,
  the comparison is not done, and depth texture values are returned directly.
  This is very useful to visualize shadow maps, for debug and demonstration
  purposes &mdash; you can view the texture as a normal grayscale (luminance) texture.
  In particular, problems with tweaking the <code>projectionNear</code> and
  <code>projectionFar</code> values become easily solvable when you can actually
  see how the texture contents look.

  <p>For OpenGL implementations, the most natural format for a shadow map texture
  is the <code>GL_DEPTH_COMPONENT</code> (see <code>ARB_depth_texture</code>).
  This makes it ideal for typical shadow map operations.
  For GLSL shader, this is best used with <code>sampler2DShadow</code>
  (for spot and directional lights) and
  <code>samplerCubeShadow</code> (for point lights).
  Unless the <code>compareMode</code> is <code>NONE</code>, in which case
  you should treat them like a normal grayscale textures
  and use the <code>sampler2D</code> or the <code>samplerCube</code> types.

  <p><i>Variance Shadow Maps</i> notes:
  If you turn on <i>Variance Shadow Maps</i> (e.g. by <a href="view3dscene.html">view3dscene</a>  menu <i>View -&gt; Shadow Maps -&gt; Variance Shadow Maps</i>), then
  the generated textures are a little different.
  If you used the simple <code>"receiveShadows"</code> field, everything is taken
  care of for you. But if you use lower-level nodes and write your own
  shaders, you must understand the differences:
  for VSM, shadow maps are treated always as <code>sampler2D</code>, with the first
  two components being <code>E(depth)</code> and <code>E(depth^2)</code>.
  See <a href="http://www.punkuser.net/vsm/">the paper about Variance Shadow Maps</a>,
  and see <a href="http://svn.code.sf.net/p/castle-engine/code/trunk/castle_game_engine/src/x3d/opengl/glsl/variance_shadow_map_common.fs">example GLSL shader code to handle them</a>.

<h3 id="section_texture_projective">5.4. Projective texture mapping</h3>

  <p>We propose a new <code>ProjectedTextureCoordinate</code> node:

  <pre class="vrml_extension_spec"><b>ProjectedTextureCoordinate : X3DTextureCoordinateNode {</b>
  SFNode     [in,out]      <b>projector   NULL      </b>  #&nbsp;[SpotLight, DirectionalLight, X3DViewpointNode]
<b>}</b>
</pre>
  <p>This node generates texture coordinates, much like the standard
  <code>TextureCoordinateGenerator</code> node.
  More precisely, a texture coordinate <i>(s, t, r, q)</i> will be generated for a fragment
  that corresponds to the shadow map pixel on the position <i>(s/q, t/q)</i>,
  with <i>r/q</i> being the depth (distance from the light source or the viewpoint,
  expressed in the same way as depth buffer values are stored in the shadow map).
  In other words, the generated texture coordinates will contain the actual
  3D geometry positions, but expressed in the projector's frustum coordinate system.
  This cooperates closely with the <code>GeneratedShadowMap.compareMode = COMPARE_R_LEQUAL</code> behavior,
  see the previous subsection.

  <p>This can be used in all situations when the light or the viewpoint act like
  a projector for a 2D texture. For shadow maps, <code>projector</code> should be
  a light source.

  <p>When a perspective <code>Viewpoint</code> is used as the <code>projector</code>,
  we need an additional rule. That's because the viewpoint doesn't explicitly
  determine the horizontal and vertical angles of view, so it doesn't precisely
  define a projection. We resolve it as follows: when the viewpoint
  <em>that is not currently bound</em> is used as a projector,
  we use <code>Viewpoint.fieldOfView</code> for both the horizontal and vertical
  view angles. When the <em>currently bound</em> viewpoint is used,
  we follow the standard <code>Viewpoint</code> specification for calculating
  view angles based on the <code>Viewpoint.fieldOfView</code> and the window sizes.
  (TODO: our current implementation doesn't treat <em>currently bound</em>
  viewpoint this way.)
  We feel that this is the most useful behavior for scene authors.

  <p>When the geometry uses a user-specified vertex shader, the implementation
  should calculate correct texture coordinates on the CPU.
  This way shader authors still benefit from the projective texturing extension.
  If the shader author wants to implement projective texturing inside the shader,
  he is of course free to do so, there's no point in using
  <code>ProjectedTextureCoordinate</code> at all then.

  <p>Note that this is not suitable for point lights. Point lights
  do not have a direction, and their shadow maps can no longer be
  single 2D textures. Instead, they must use six 2D maps.
  For point lights, it's expected that the shader code will have
  to do the appropriate
  texture coordinate calculation: a direction to the point light
  (to sample the shadow map cube) and a distance to it (to compare
  with the depth read from the texture).

  <p><i>Deprecated:</i> In older engine versions, instead of this node
  you had to use <code>TextureCoordinateGenerator.mode = "PROJECTION"</code>
  and <code>TextureCoordinateGenerator.projectedLight</code>. This is still
  handled (for compatibility), but should not be used in new models.

<h3 id="section_receive_shadows_to_lower_level">5.5. How the receiveShadows field maps to the lower-level extensions</h3>

  <p>Placing a light on the <code>receiveShadows</code> list is equivalent to
  adding the appropriate <code>GeneratedShadowMap</code> to the shape's textures,
  and adding the appropriate <code>ProjectedTextureCoordinate</code> to the geometry
  <code>texCoord</code> field. Also, <code>receiveShadows</code> makes
  the right shading (for example by shaders) automatically used.

  <p>In fact, the <code>receiveShadows</code> feature may be
  implemented by a simple transformation of the X3D node graph.
  Since the <code>receiveShadows</code> and <code>defaultShadowMap</code>
  fields are not exposed (they do not have accompanying
  input and output events) it's enough to perform such transformation
  once after loading the scene.
  Note that the texture nodes of the shadow receivers
  may have to be internally changed to multi-texture nodes during this operation.

  <p>An author may also <em>optionally</em> specify
  a <code>GeneratedShadowMap</code> node inside the light's
  <code>defaultShadowMap</code> field. See the <a href="#section_ext_light_projective">lights extensions section</a>
  for <code>defaultShadowMap</code> declaration. Note that when
  <code>GeneratedShadowMap</code>
  is placed in a <code>X3DLightNode.defaultShadowMap</code> field,
  then the <code>GeneratedShadowMap.light</code> value is ignored (we always
  use the light containing <code>defaultShadowMap</code> declaration then).

  <p>Leaving the <code>defaultShadowMap</code> as <code>NULL</code> means that an
  implicit shadow map with default browser settings should be generated
  for this light. This must behave like <code>update</code> was set to
  <code>ALWAYS</code>.

  <p>In effect, to enable the shadows the author must merely
  specify which shapes receive the shadows (and from which lights)
  by the <code>Appearance.receiveShadows</code> field. This way the author
  doesn't have to deal with lower-level tasks:

  <ol>
    <li>Using <code>GeneratedShadowMap</code> nodes.</li>
    <li>Using <code>ProjectedTextureCoordinate</code> nodes.</li>
    <li>Writing own shaders.</li>
  </ol>

<h2 id="section_shadow_caster">6. Optionally specify shadow casters (<code>Appearance.shadowCaster</code>)</h2>

  <p>By default, every <code>Shape</code> in the scene casts a shadow.
  This is the most common setup for shadows.
  However it's sometimes useful to explicitly
  disable shadow casting (blocking of the light) for some tricky shapes.
  For example, this is usually desired for shapes that visualize
  the light source position.
  For this purpose we extend the <code>Appearance</code> node:

  <pre class="vrml_extension_spec"><b>Appearance {</b>
  ... all Appearance fields ...
  SFBool     [in,out]      <b>shadowCaster     TRUE      </b>
<b>}</b>
</pre>
  <p>Note that if you disable shadow casting on your shadow receivers
  (that is, you make all the objects only casting or only receiving the shadows,
  but not both) then you avoid some offset problems with shadow maps. The <code>bias</code>
  and <code>scale</code> parameters of the <code>GeneratedShadowMap</code>
  become less crucial then.

  <p>This is honoured by all our shadow implementations:
  shadow volumes, shadow maps (that is, both methods for dynamic
  shadows in OpenGL) and also by our ray-tracers.</p>

  <p>Note that <i>no shadow algorithm can deal with transparency by
  alpha-blending</i>. So these shapes are not treated as shadow casters,
  by any shadow algorithm right now.

</div><div class="col-sm-3 col-sm-pull-9 well sidebar">
  <div class="sidebar">
    <div class="sidebar_title"><a href="vrml_x3d.html">Scene Graph (X3D)</a></div><ul><li><a href="demo_models.html">Demo models</a></li><li><a href="x3d_implementation_status.html">Standard X3D Components</a><ul><li><a href="x3d_implementation_core.html">Core</a></li><li><a href="x3d_implementation_time.html">Time</a></li><li><a href="x3d_implementation_networking.html">Networking</a></li><li><a href="x3d_implementation_grouping.html">Grouping</a></li><li><a href="x3d_implementation_rendering.html">Rendering</a></li><li><a href="x3d_implementation_shape.html">Shape</a><ul><li><a href="https://castle-engine.sourceforge.io/x3d_implementation_shape_extensions.php">Extensions</a></li></ul></li><li><a href="x3d_implementation_geometry3d.html">Geometry3D</a><ul><li><a href="https://castle-engine.sourceforge.io/x3d_implementation_geometry3d_extensions.php">Extensions</a></li></ul></li><li><a href="x3d_implementation_geometry2d.html">Geometry2D</a></li><li><a href="x3d_implementation_text.html">Text</a><ul><li><a href="https://castle-engine.sourceforge.io/x3d_implementation_text_extensions.php">Extensions</a></li></ul></li><li><a href="x3d_implementation_sound.html">Sound</a></li><li><a href="x3d_implementation_lighting.html">Lighting</a></li><li><a href="x3d_implementation_texturing.html">Texturing</a><ul><li><a href="https://castle-engine.sourceforge.io/x3d_implementation_texturing_extensions.php">Extensions</a></li><li><a href="https://castle-engine.sourceforge.io/x3d_multi_texturing.php">X3D MultiTexturing problems and proposed solutions</a></li></ul></li><li><a href="x3d_implementation_interpolation.html">Interpolation</a><ul><li><a href="https://castle-engine.sourceforge.io/x3d_implementation_interpolation_extensions.php">Extensions</a></li></ul></li><li><a href="x3d_implementation_pointingdevicesensor.html">Pointing device sensor</a></li><li><a href="x3d_implementation_keydevicesensor.html">Key device sensor</a></li><li><a href="x3d_implementation_environmentalsensor.html">Environmental sensor</a></li><li><a href="x3d_implementation_navigation.html">Navigation</a><ul><li><a href="https://castle-engine.sourceforge.io/x3d_implementation_navigation_extensions.php">Extensions</a></li></ul></li><li><a href="x3d_implementation_environmentaleffects.html">Environmental effects</a></li><li><a href="x3d_implementation_hanim.html">H-Anim</a></li><li><a href="x3d_implementation_nurbs.html">NURBS</a><ul><li><a href="x3d_implementation_nurbs.html#section_homogeneous_coordinates">Control points are in homogeneous coordinates</a></li></ul></li><li><a href="x3d_implementation_scripting.html">Scripting</a></li><li><a href="x3d_implementation_eventutilities.html">Event utilities</a><ul><li><a href="https://castle-engine.sourceforge.io/x3d_implementation_eventutilities_extensions.php">Extensions</a></li></ul></li><li><a href="x3d_implementation_shaders.html">Programmable shaders</a></li><li><a href="x3d_implementation_cadgeometry.html">CAD geometry</a></li><li><a href="x3d_implementation_texturing3d.html">Texturing3D</a></li><li><a href="x3d_implementation_cubemaptexturing.html">Cube map environmental texturing</a></li></ul></li><li><a href="https://castle-engine.sourceforge.io/x3d_larger_extensions.php">Larger X3D Extensions</a><ul><li><a href="compositing_shaders.html">Compositing Shaders</a></li><li><a href="x3d_extensions_screen_effects.html">Screen Effects</a></li><li>Shadow Maps</li><li><a href="https://castle-engine.sourceforge.io/x3d_extensions_shadow_volumes.php">Shadow Volumes</a></li><li><a href="x3d_extensions_vrml1.html">(Old) VRML 1.0</a></li></ul></li><li><a href="x3d_extensions.html">Complete list of X3D Extensions</a></li><li><a href="castle_script.html">CastleScript language reference</a></li><li><a href="castle_animation_frames.html">Castle Animation Frames (castle-anim-frames) file format</a></li><li><a href="x3d_time_origin_considered_uncomfortable.html">VRML / X3D time origin considered uncomfortable</a></li><li><a href="nist_vrml_test_suite.html">NIST conformace test suite</a></li></ul></div></div></div></div>

  <div class="panel-footer">
    <p><span class="page_copyright">Copyright <a href="http://michalis.ii.uni.wroc.pl/~michalis/">Michalis Kamburelis</a>.
    Some images copyright <a href="http://cat-astrophe-games.com/">Cat-astrophe Games</a> and Paweł Wojciechowicz.
    You can redistribute this on terms of the
    <a href="http://www.gnu.org/licenses/gpl.html">GNU General Public License</a>.</span>

    <p><a href="https://sourceforge.net/projects/castle-engine">Hosted by SourceForge.net</a>.

    <p>We use <a href="https://en.wikipedia.org/wiki/HTTP_cookie">cookies</a>.
    Like every other frickin' website on the Internet.
    Blink twice if you understand.
  </div>

  
<!-- jQuery (necessary for Bootstrap's JavaScript plugins).
     Used also by colorbox. -->
<script src="https://castle-engine.sourceforge.io/kambi-php-lib/js/jquery.min.js" type="text/javascript"></script>
<!-- Include colorbox after jQuery is known -->
<script src="https://castle-engine.sourceforge.io/kambi-php-lib/colorbox/jquery.colorbox-min.js" type="text/javascript"></script>
<script type="text/javascript">
  jQuery('a.screenshot').colorbox({opacity: 0.9, rel:'screenshot', maxWidth:'90%', maxHeight:'90%'});
</script>
<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://castle-engine.sourceforge.io/kambi-php-lib/bootstrap/js/bootstrap.min.js"></script>
</body>
</html>

